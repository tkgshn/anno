{
  "version": 3,
  "sources": ["../src/browser-polyfill.ts", "../src/storage.ts", "../src/popup.ts"],
  "sourcesContent": ["// Browser API compatibility layer with Safari-specific enhancements\n\n// Type for Safari-specific properties\ninterface SafariExtensions {\n  _isSafari?: boolean;\n  _isIOS?: boolean;\n}\n\n// Create a browser API wrapper\nexport const browser = (() => {\n  // Use native browser API if available (Safari)\n  if (typeof (globalThis as any).browser !== 'undefined') {\n    const api = (globalThis as any).browser;\n    \n    // Add Safari detection properties\n    api._isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    api._isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;\n    \n    return api;\n  }\n  \n  // Use chrome API if available (Chrome/Edge)\n  if (typeof (globalThis as any).chrome !== 'undefined' && (globalThis as any).chrome.runtime) {\n    const api = (globalThis as any).chrome;\n    \n    // Add Safari detection properties (will be false)\n    api._isSafari = false;\n    api._isIOS = false;\n    \n    return api;\n  }\n  \n  // If neither is available, we're in a bad state\n  console.error(\"No browser extension API found!\");\n  \n  // Return a minimal mock to prevent crashes\n  return {\n    _isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),\n    _isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream,\n    runtime: {\n      onMessage: { addListener: () => {} },\n      sendMessage: () => Promise.resolve(),\n      getURL: (path: string) => path\n    },\n    storage: {\n      sync: {\n        get: () => Promise.resolve({}),\n        set: () => Promise.resolve()\n      },\n      local: {\n        get: () => Promise.resolve({}),\n        set: () => Promise.resolve()\n      }\n    },\n    action: {\n      onClicked: { addListener: () => {} }\n    },\n    tabs: {\n      sendMessage: () => Promise.resolve(),\n      query: () => Promise.resolve([])\n    }\n  } as any;\n})();\n\n// Also export as chrome for compatibility\nexport const chrome = browser;\n\n// Safari-specific API fallbacks and utilities\nexport const safariCompat = {\n  // Safari doesn't support browser.runtime.openOptionsPage on iOS\n  openOptionsPage: async (): Promise<void> => {\n    try {\n      if (browser.runtime.openOptionsPage && !browser._isIOS) {\n        await browser.runtime.openOptionsPage();\n      } else {\n        // Fallback: open in new tab\n        const optionsUrl = browser.runtime.getURL(\"options.html\");\n        await browser.tabs.create({ url: optionsUrl });\n      }\n    } catch (error) {\n      console.error(\"[safariCompat] Failed to open options page:\", error);\n      // Last resort: try to open in current tab\n      const optionsUrl = browser.runtime.getURL(\"options.html\");\n      window.open(optionsUrl, \"_blank\");\n    }\n  },\n  \n  // Check if running on Safari\n  isSafari: (): boolean => browser._isSafari || false,\n  \n  // Check if running on iOS\n  isIOS: (): boolean => browser._isIOS || false,\n  \n  // Safari storage fallbacks (Safari has 10MB limit vs Chrome's unlimited)\n  safeStorageSet: async (items: Record<string, any>): Promise<void> => {\n    try {\n      await browser.storage.local.set(items);\n    } catch (error: any) {\n      if (error.message?.includes(\"quota\")) {\n        console.error(\"[safariCompat] Storage quota exceeded, attempting cleanup...\");\n        // Try to clear old data\n        const keys = Object.keys(await browser.storage.local.get());\n        if (keys.length > 100) {\n          // Remove oldest entries (assuming keys have timestamps)\n          const toRemove = keys.slice(0, Math.floor(keys.length * 0.2));\n          await browser.storage.local.remove(toRemove);\n          // Retry\n          await browser.storage.local.set(items);\n        }\n      } else {\n        throw error;\n      }\n    }\n  },\n  \n  // Context menus compatibility (not supported on iOS)\n  supportsContextMenus: (): boolean => {\n    return !browser._isIOS && typeof browser.contextMenus !== \"undefined\";\n  },\n  \n  // Permissions check with Safari fallbacks\n  hasPermission: async (permission: string): Promise<boolean> => {\n    if (!browser.permissions?.contains) {\n      console.warn(\"[safariCompat] Permissions API not available\");\n      return false;\n    }\n    \n    try {\n      const result = await browser.permissions.contains({ permissions: [permission] });\n      return result;\n    } catch (error) {\n      console.error(`[safariCompat] Failed to check permission ${permission}:`, error);\n      return false;\n    }\n  }\n};\n\n// Make browser API available globally if needed\ndeclare global {\n  interface Window {\n    browser?: any;\n    chrome?: any;\n  }\n}\n\nif (typeof (globalThis as any).browser === \"undefined\") {\n  (globalThis as any).browser = browser;\n}\nif (typeof (globalThis as any).chrome === \"undefined\") {\n  (globalThis as any).chrome = browser;\n}", "import { browser, safariCompat } from \"./browser-polyfill\";\nimport type { ExtensionSettings } from \"./types/messages\";\n\n// Safari storage limits\nconst SAFARI_STORAGE_LIMIT = 10 * 1024 * 1024; // 10MB\nconst STORAGE_WARNING_THRESHOLD = 0.8; // Warn at 80% usage\n\nexport const initialStorageValues: ExtensionSettings = {\n  annoProjectName: \"\",\n  enableAutoInjection: true,\n  debugMode: false,\n  storageQuotaWarningThreshold: STORAGE_WARNING_THRESHOLD,\n};\n\nexport interface Settings extends ExtensionSettings {\n  project?: string;\n  encryptedApiKey?: string;\n  maxTokens?: number;\n  temperature?: number;\n  autoInsertSummary?: boolean;\n}\n\n// Storage usage monitoring\nexport interface StorageInfo {\n  bytesUsed: number;\n  quotaBytes: number;\n  percentUsed: number;\n  isNearQuota: boolean;\n}\n\n/**\n * Get current storage usage information\n */\nexport async function getStorageInfo(): Promise<StorageInfo> {\n  try {\n    // Safari doesn't support browser.storage.local.getBytesInUse\n    if ('getBytesInUse' in browser.storage.local && typeof browser.storage.local.getBytesInUse === 'function') {\n      const bytesUsed = await browser.storage.local.getBytesInUse();\n      const quotaBytes = SAFARI_STORAGE_LIMIT;\n      const percentUsed = bytesUsed / quotaBytes;\n      \n      return {\n        bytesUsed,\n        quotaBytes,\n        percentUsed,\n        isNearQuota: percentUsed >= STORAGE_WARNING_THRESHOLD,\n      };\n    } else {\n      // Fallback: estimate storage usage\n      const allData = await browser.storage.local.get();\n      const dataString = JSON.stringify(allData);\n      const bytesUsed = new Blob([dataString]).size;\n      const quotaBytes = SAFARI_STORAGE_LIMIT;\n      const percentUsed = bytesUsed / quotaBytes;\n      \n      return {\n        bytesUsed,\n        quotaBytes,\n        percentUsed,\n        isNearQuota: percentUsed >= STORAGE_WARNING_THRESHOLD,\n      };\n    }\n  } catch (error) {\n    console.error(\"[storage] Failed to get storage info:\", error);\n    return {\n      bytesUsed: 0,\n      quotaBytes: SAFARI_STORAGE_LIMIT,\n      percentUsed: 0,\n      isNearQuota: false,\n    };\n  }\n}\n\n/**\n * Load settings from browser storage with error handling\n */\nexport async function loadSettings(): Promise<Settings> {\n  try {\n    // Try sync storage first (smaller quota but syncs across devices)\n    const syncData = await browser.storage.sync.get(initialStorageValues);\n    \n    // Merge with local storage for larger data\n    const localData = await browser.storage.local.get();\n    \n    return { ...initialStorageValues, ...syncData, ...localData } as Settings;\n  } catch (error) {\n    console.error(\"[storage] Failed to load settings:\", error);\n    return initialStorageValues as Settings;\n  }\n}\n\n/**\n * Save settings to browser storage with Safari compatibility\n */\nexport async function saveSettings(settings: Partial<Settings>): Promise<void> {\n  try {\n    // Separate small settings for sync storage\n    const syncSettings: Partial<Settings> = {\n      annoProjectName: settings.annoProjectName,\n      enableAutoInjection: settings.enableAutoInjection,\n      debugMode: settings.debugMode,\n    };\n    \n    // Large data goes to local storage\n    const localSettings: Partial<Settings> = {\n      project: settings.project,\n      encryptedApiKey: settings.encryptedApiKey,\n      maxTokens: settings.maxTokens,\n      temperature: settings.temperature,\n      autoInsertSummary: settings.autoInsertSummary,\n    };\n    \n    // Remove undefined values\n    const cleanSyncSettings = Object.fromEntries(\n      Object.entries(syncSettings).filter(([_, v]) => v !== undefined)\n    );\n    const cleanLocalSettings = Object.fromEntries(\n      Object.entries(localSettings).filter(([_, v]) => v !== undefined)\n    );\n    \n    // Save to appropriate storage\n    if (Object.keys(cleanSyncSettings).length > 0) {\n      await browser.storage.sync.set(cleanSyncSettings);\n    }\n    \n    if (Object.keys(cleanLocalSettings).length > 0) {\n      await safariCompat.safeStorageSet(cleanLocalSettings);\n    }\n    \n    // Check storage usage after save\n    const storageInfo = await getStorageInfo();\n    if (storageInfo.isNearQuota) {\n      console.warn(\n        `[storage] Storage usage is at ${(storageInfo.percentUsed * 100).toFixed(1)}% of quota`\n      );\n    }\n  } catch (error) {\n    console.error(\"[storage] Failed to save settings:\", error);\n    throw error;\n  }\n}\n\n/**\n * Clear old or unnecessary data to free up storage\n */\nexport async function cleanupStorage(): Promise<void> {\n  try {\n    const storageInfo = await getStorageInfo();\n    if (!storageInfo.isNearQuota) {\n      return;\n    }\n    \n    console.log(\"[storage] Cleaning up storage...\");\n    \n    // Get all stored data\n    const allData = await browser.storage.local.get();\n    const keys = Object.keys(allData);\n    \n    // Identify old or large entries (customize based on your data structure)\n    const keysToRemove: string[] = [];\n    \n    for (const key of keys) {\n      // Remove old cache entries (assuming they have timestamps)\n      if (key.startsWith(\"cache_\") && allData[key]?.timestamp) {\n        const age = Date.now() - allData[key].timestamp;\n        if (age > 7 * 24 * 60 * 60 * 1000) { // 7 days\n          keysToRemove.push(key);\n        }\n      }\n      \n      // Remove large entries that aren't critical\n      const dataSize = new Blob([JSON.stringify(allData[key])]).size;\n      if (dataSize > 100 * 1024 && !isEssentialData(key)) { // 100KB\n        keysToRemove.push(key);\n      }\n    }\n    \n    if (keysToRemove.length > 0) {\n      await browser.storage.local.remove(keysToRemove);\n      console.log(`[storage] Removed ${keysToRemove.length} entries`);\n    }\n  } catch (error) {\n    console.error(\"[storage] Cleanup failed:\", error);\n  }\n}\n\n/**\n * Check if a storage key contains essential data\n */\nfunction isEssentialData(key: string): boolean {\n  const essentialKeys = [\n    \"annoProjectName\",\n    \"encryptedApiKey\",\n    \"settings\",\n    \"userPreferences\",\n  ];\n  \n  return essentialKeys.some(essential => key.includes(essential));\n}\n\n/**\n * Encrypt API key using Web Crypto API\n */\nexport async function encryptApiKey(apiKey: string): Promise<string> {\n  try {\n    // Generate a key from a passphrase (in production, use a secure key)\n    const encoder = new TextEncoder();\n    const keyMaterial = await crypto.subtle.importKey(\n      \"raw\",\n      encoder.encode(\"anno-safari-extension-key\"), // Use a secure key in production\n      { name: \"PBKDF2\" },\n      false,\n      [\"deriveKey\"]\n    );\n    \n    const key = await crypto.subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt: encoder.encode(\"anno-salt\"), // Use a random salt in production\n        iterations: 100000,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: 256 },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n    \n    // Encrypt the API key\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encrypted = await crypto.subtle.encrypt(\n      { name: \"AES-GCM\", iv },\n      key,\n      encoder.encode(apiKey)\n    );\n    \n    // Combine IV and encrypted data\n    const combined = new Uint8Array(iv.length + encrypted.byteLength);\n    combined.set(iv);\n    combined.set(new Uint8Array(encrypted), iv.length);\n    \n    // Convert to base64\n    return btoa(String.fromCharCode(...combined));\n  } catch (error) {\n    console.error(\"[storage] Encryption failed:\", error);\n    // Fallback to simple encoding (not secure)\n    return btoa(apiKey);\n  }\n}\n\n/**\n * Decrypt API key using Web Crypto API\n */\nexport async function decryptApiKey(encryptedKey: string): Promise<string> {\n  try {\n    // Convert from base64\n    const combined = Uint8Array.from(atob(encryptedKey), c => c.charCodeAt(0));\n    \n    // Extract IV and encrypted data\n    const iv = combined.slice(0, 12);\n    const encrypted = combined.slice(12);\n    \n    // Generate the same key\n    const encoder = new TextEncoder();\n    const keyMaterial = await crypto.subtle.importKey(\n      \"raw\",\n      encoder.encode(\"anno-safari-extension-key\"), // Use the same secure key\n      { name: \"PBKDF2\" },\n      false,\n      [\"deriveKey\"]\n    );\n    \n    const key = await crypto.subtle.deriveKey(\n      {\n        name: \"PBKDF2\",\n        salt: encoder.encode(\"anno-salt\"), // Use the same salt\n        iterations: 100000,\n        hash: \"SHA-256\",\n      },\n      keyMaterial,\n      { name: \"AES-GCM\", length: 256 },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    );\n    \n    // Decrypt\n    const decrypted = await crypto.subtle.decrypt(\n      { name: \"AES-GCM\", iv },\n      key,\n      encrypted\n    );\n    \n    return new TextDecoder().decode(decrypted);\n  } catch (error) {\n    console.error(\"[storage] Decryption failed:\", error);\n    // Fallback to simple decoding\n    return atob(encryptedKey);\n  }\n}", "// Anno Safari\u62E1\u5F35 Popup UI \u30ED\u30B8\u30C3\u30AF\u96DB\u5F62\n// JSDoc\u4ED8\u304D\n\nimport { browser } from \"./browser-polyfill\";\nimport { loadSettings, saveSettings, encryptApiKey, decryptApiKey, Settings } from \"./storage\";\n\n/**\n * \u73FE\u5728\u306E\u30A2\u30AF\u30C6\u30A3\u30D6\u30BF\u30D6\u306BextractPageData\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u9001\u308A\u3001\u672C\u6587\u30C7\u30FC\u30BF\u3092\u53D6\u5F97\n */\nasync function getPageDataFromActiveTab(): Promise<{ title: string; url: string; text: string } | null> {\n    return new Promise((resolve) => {\n        browser.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n            const tab = tabs[0];\n            if (!tab?.id) return resolve(null);\n            browser.tabs.sendMessage(tab.id, { type: \"extractPageData\" }, (res) => {\n                resolve(res ?? null);\n            });\n        });\n    });\n}\n\n/**\n * background\u306B\u8981\u7D04\u751F\u6210\u30EA\u30AF\u30A8\u30B9\u30C8\u3092\u9001\u308A\u3001\u8981\u7D04\u3092\u53D7\u3051\u53D6\u308B\n */\nasync function requestSummaryFromBackground({ apiKey, model, text, url, maxTokens, temperature }: {\n    apiKey: string;\n    model: string;\n    text: string;\n    url: string;\n    maxTokens: number;\n    temperature: number;\n}): Promise<string> {\n    return new Promise((resolve, reject) => {\n        browser.runtime.sendMessage(\n            {\n                type: \"generateSummary\",\n                apiKey,\n                model,\n                text,\n                url,\n                maxTokens,\n                temperature,\n            },\n            (res) => {\n                if (res?.summary) return resolve(res.summary);\n                reject(res?.error || \"\u8981\u7D04\u751F\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F\");\n            }\n        );\n    });\n}\n\n/**\n * Scrapbox\u6295\u7A3F\u7528\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u3092\u751F\u6210\n */\nfunction buildScrapboxBody({ summary, url, title }: { summary: string; url: string; title: string }): string {\n    return [\n        '> [chatgpt.icon] ' + summary,\n        `> [source.icon] [${url} \u30AF\u30EA\u30C3\u30D7\u5143]`,\n        '> [tags] #anno #summary',\n        '--',\n        `> ${title}`,\n    ].join('\\n');\n}\n\n/**\n * background\u306BScrapbox\u6295\u7A3F\u30EA\u30AF\u30A8\u30B9\u30C8\u3092\u9001\u308B\n */\nasync function postToScrapbox({ body, title }: { body: string; title: string }): Promise<void> {\n    return new Promise((resolve, reject) => {\n        browser.runtime.sendMessage(\n            { type: \"postToScrapbox\", body, title },\n            (res) => {\n                if (res?.success) return resolve();\n                reject(res?.error || \"Scrapbox\u6295\u7A3F\u306B\u5931\u6557\u3057\u307E\u3057\u305F\");\n            }\n        );\n    });\n}\n\n/**\n * Popup\u30D5\u30A9\u30FC\u30E0\u306E\u521D\u671F\u5316\u30FB\u30A4\u30D9\u30F3\u30C8\u30CF\u30F3\u30C9\u30E9\u767B\u9332\n */\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n    const clipBtn = document.getElementById(\"clip-btn\") as HTMLButtonElement;\n    const openSettingsBtn = document.getElementById(\"open-settings-btn\") as HTMLButtonElement;\n    const feedback = document.getElementById(\"feedback\") as HTMLDivElement;\n\n    // \u8A2D\u5B9A\u5024\u3092browser.storage\u304B\u3089\u53D6\u5F97\n    const settings: Settings = await loadSettings();\n    const project = settings.project || \"\";\n    const apiKey = settings.encryptedApiKey ? await decryptApiKey(settings.encryptedApiKey) : \"\";\n    \n    // \u30C7\u30D0\u30C3\u30B0\u7528\uFF1A\u8A2D\u5B9A\u5185\u5BB9\u3092\u30B3\u30F3\u30BD\u30FC\u30EB\u306B\u51FA\u529B\n    console.log(\"Anno Settings:\", {\n        project: project || \"\u672A\u8A2D\u5B9A\",\n        annoProjectName: settings.annoProjectName || \"\u672A\u8A2D\u5B9A\",\n        hasApiKey: !!apiKey,\n        allSettings: settings\n    });\n\n    // \u8A2D\u5B9A\u672A\u5B8C\u4E86\u306A\u3089Clip\u30DC\u30BF\u30F3\u975E\u8868\u793A\uFF06\u8A2D\u5B9A\u30DC\u30BF\u30F3\u8868\u793A\n    if (!project || !apiKey) {\n        clipBtn.style.display = \"none\";\n        openSettingsBtn.style.display = \"block\";\n        openSettingsBtn.addEventListener(\"click\", () => {\n            browser.runtime.openOptionsPage();\n        });\n        feedback.textContent = \"\u521D\u56DE\u306FProject\u3068API Key\u306E\u8A2D\u5B9A\u304C\u5FC5\u8981\u3067\u3059\";\n        return;\n    } else {\n        clipBtn.style.display = \"block\";\n        openSettingsBtn.style.display = \"none\";\n    }\n\n    // Clip\u30DC\u30BF\u30F3\u62BC\u4E0B\u6642\u306E\u51E6\u7406\uFF08\u65E2\u5B58\u306E\u8981\u7D04\u30FB\u6295\u7A3F\u30D5\u30ED\u30FC\u3092\u3053\u3053\u306B\uFF09\n    document.getElementById(\"clip-form\")?.addEventListener(\"submit\", async (e) => {\n        e.preventDefault();\n        feedback.textContent = \"\u2026generating summary\";\n        clipBtn.disabled = true;\n\n        // \u30E2\u30C7\u30EB\u306F\u5E38\u306Bgpt-4o\u306B\u56FA\u5B9A\n        const model = \"gpt-4o\";\n        const maxTokens = settings.maxTokens || 160;\n        const temperature = settings.temperature ?? 0.3;\n        const autoInsert = settings.autoInsertSummary ?? true;\n\n        // \u672C\u6587\u30C7\u30FC\u30BF\u3092content script\u304B\u3089\u53D6\u5F97\n        const pageData = await getPageDataFromActiveTab();\n        if (!pageData) {\n            feedback.textContent = \"\u672C\u6587\u62BD\u51FA\u306B\u5931\u6557\u3057\u307E\u3057\u305F\";\n            clipBtn.disabled = false;\n            return;\n        }\n\n        // background\u306B\u8981\u7D04\u751F\u6210\u30EA\u30AF\u30A8\u30B9\u30C8\n        let summary = \"\";\n        try {\n            summary = await requestSummaryFromBackground({\n                apiKey,\n                model,\n                text: pageData.text,\n                url: pageData.url,\n                maxTokens,\n                temperature,\n            });\n            console.log(\"\u8981\u7D04\", summary);\n        } catch (e) {\n            feedback.textContent = `\u8981\u7D04\u751F\u6210\u30A8\u30E9\u30FC: ${e}`;\n            clipBtn.disabled = false;\n            return;\n        }\n\n        // Scrapbox\u6295\u7A3F\u7528\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u751F\u6210\n        const body = buildScrapboxBody({ summary, url: pageData.url, title: pageData.title });\n        try {\n            await postToScrapbox({ body, title: pageData.title });\n            feedback.textContent = \"done\";\n        } catch (e) {\n            feedback.textContent = `Scrapbox\u6295\u7A3F\u30A8\u30E9\u30FC: ${e}`;\n        }\n        clipBtn.disabled = false;\n    });\n});\n\n/**\n * \u4ECA\u5F8C\u306E\u62E1\u5F35\u30DD\u30A4\u30F3\u30C8:\n * - browser.storage\u3068\u306E\u9023\u643A\n * - AES-GCM\u6697\u53F7\u5316/\u5FA9\u53F7\n * - OpenAI API\u547C\u3073\u51FA\u3057\n * - i18n\u5BFE\u5FDC\n */\n"],
  "mappings": "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",
  "names": ["e"]
}
