{
  "version": 3,
  "sources": ["../src/browser-polyfill.ts", "../src/scrapboxContent.ts"],
  "sourcesContent": ["// Browser API compatibility layer with Safari-specific enhancements\n\n// Type for Safari-specific properties\ninterface SafariExtensions {\n  _isSafari?: boolean;\n  _isIOS?: boolean;\n}\n\n// Create a browser API wrapper\nexport const browser = (() => {\n  // Use native browser API if available (Safari)\n  if (typeof (globalThis as any).browser !== 'undefined') {\n    const api = (globalThis as any).browser;\n    \n    // Add Safari detection properties\n    api._isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    api._isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;\n    \n    return api;\n  }\n  \n  // Use chrome API if available (Chrome/Edge)\n  if (typeof (globalThis as any).chrome !== 'undefined' && (globalThis as any).chrome.runtime) {\n    const api = (globalThis as any).chrome;\n    \n    // Add Safari detection properties (will be false)\n    api._isSafari = false;\n    api._isIOS = false;\n    \n    return api;\n  }\n  \n  // If neither is available, we're in a bad state\n  console.error(\"No browser extension API found!\");\n  \n  // Return a minimal mock to prevent crashes\n  return {\n    _isSafari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent),\n    _isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream,\n    runtime: {\n      onMessage: { addListener: () => {} },\n      sendMessage: () => Promise.resolve(),\n      getURL: (path: string) => path\n    },\n    storage: {\n      sync: {\n        get: () => Promise.resolve({}),\n        set: () => Promise.resolve()\n      },\n      local: {\n        get: () => Promise.resolve({}),\n        set: () => Promise.resolve()\n      }\n    },\n    action: {\n      onClicked: { addListener: () => {} }\n    },\n    tabs: {\n      sendMessage: () => Promise.resolve(),\n      query: () => Promise.resolve([])\n    }\n  } as any;\n})();\n\n// Also export as chrome for compatibility\nexport const chrome = browser;\n\n// Safari-specific API fallbacks and utilities\nexport const safariCompat = {\n  // Safari doesn't support browser.runtime.openOptionsPage on iOS\n  openOptionsPage: async (): Promise<void> => {\n    try {\n      if (browser.runtime.openOptionsPage && !browser._isIOS) {\n        await browser.runtime.openOptionsPage();\n      } else {\n        // Fallback: open in new tab\n        const optionsUrl = browser.runtime.getURL(\"options.html\");\n        await browser.tabs.create({ url: optionsUrl });\n      }\n    } catch (error) {\n      console.error(\"[safariCompat] Failed to open options page:\", error);\n      // Last resort: try to open in current tab\n      const optionsUrl = browser.runtime.getURL(\"options.html\");\n      window.open(optionsUrl, \"_blank\");\n    }\n  },\n  \n  // Check if running on Safari\n  isSafari: (): boolean => browser._isSafari || false,\n  \n  // Check if running on iOS\n  isIOS: (): boolean => browser._isIOS || false,\n  \n  // Safari storage fallbacks (Safari has 10MB limit vs Chrome's unlimited)\n  safeStorageSet: async (items: Record<string, any>): Promise<void> => {\n    try {\n      await browser.storage.local.set(items);\n    } catch (error: any) {\n      if (error.message?.includes(\"quota\")) {\n        console.error(\"[safariCompat] Storage quota exceeded, attempting cleanup...\");\n        // Try to clear old data\n        const keys = Object.keys(await browser.storage.local.get());\n        if (keys.length > 100) {\n          // Remove oldest entries (assuming keys have timestamps)\n          const toRemove = keys.slice(0, Math.floor(keys.length * 0.2));\n          await browser.storage.local.remove(toRemove);\n          // Retry\n          await browser.storage.local.set(items);\n        }\n      } else {\n        throw error;\n      }\n    }\n  },\n  \n  // Context menus compatibility (not supported on iOS)\n  supportsContextMenus: (): boolean => {\n    return !browser._isIOS && typeof browser.contextMenus !== \"undefined\";\n  },\n  \n  // Permissions check with Safari fallbacks\n  hasPermission: async (permission: string): Promise<boolean> => {\n    if (!browser.permissions?.contains) {\n      console.warn(\"[safariCompat] Permissions API not available\");\n      return false;\n    }\n    \n    try {\n      const result = await browser.permissions.contains({ permissions: [permission] });\n      return result;\n    } catch (error) {\n      console.error(`[safariCompat] Failed to check permission ${permission}:`, error);\n      return false;\n    }\n  }\n};\n\n// Make browser API available globally if needed\ndeclare global {\n  interface Window {\n    browser?: any;\n    chrome?: any;\n  }\n}\n\nif (typeof (globalThis as any).browser === \"undefined\") {\n  (globalThis as any).browser = browser;\n}\nif (typeof (globalThis as any).chrome === \"undefined\") {\n  (globalThis as any).chrome = browser;\n}", "import { browser } from \"./browser-polyfill\";\n\nconst handleDocumentChange = () => {\n  if (!document.querySelector(\".page\")) {\n    return;\n  }\n  mutationObserver.disconnect();\n\n  const scriptElement = document.createElement(\"script\");\n  scriptElement.src = browser.runtime.getURL(\"dist/scrapboxUserScript.js\");\n  document.body.append(scriptElement);\n};\nconst mutationObserver = new MutationObserver(handleDocumentChange);\nhandleDocumentChange();\nmutationObserver.observe(document, {\n  subtree: true,\n  childList: true,\n  characterData: true,\n});\n"],
  "mappings": ";AASO,IAAM,WAAW,MAAM;AAE5B,MAAI,OAAQ,WAAmB,YAAY,aAAa;AACtD,UAAM,MAAO,WAAmB;AAGhC,QAAI,YAAY,iCAAiC,KAAK,UAAU,SAAS;AACzE,QAAI,SAAS,mBAAmB,KAAK,UAAU,SAAS,KAAK,CAAE,OAAe;AAE9E,WAAO;AAAA,EACT;AAGA,MAAI,OAAQ,WAAmB,WAAW,eAAgB,WAAmB,OAAO,SAAS;AAC3F,UAAM,MAAO,WAAmB;AAGhC,QAAI,YAAY;AAChB,QAAI,SAAS;AAEb,WAAO;AAAA,EACT;AAGA,UAAQ,MAAM,iCAAiC;AAG/C,SAAO;AAAA,IACL,WAAW,iCAAiC,KAAK,UAAU,SAAS;AAAA,IACpE,QAAQ,mBAAmB,KAAK,UAAU,SAAS,KAAK,CAAE,OAAe;AAAA,IACzE,SAAS;AAAA,MACP,WAAW,EAAE,aAAa,MAAM;AAAA,MAAC,EAAE;AAAA,MACnC,aAAa,MAAM,QAAQ,QAAQ;AAAA,MACnC,QAAQ,CAAC,SAAiB;AAAA,IAC5B;AAAA,IACA,SAAS;AAAA,MACP,MAAM;AAAA,QACJ,KAAK,MAAM,QAAQ,QAAQ,CAAC,CAAC;AAAA,QAC7B,KAAK,MAAM,QAAQ,QAAQ;AAAA,MAC7B;AAAA,MACA,OAAO;AAAA,QACL,KAAK,MAAM,QAAQ,QAAQ,CAAC,CAAC;AAAA,QAC7B,KAAK,MAAM,QAAQ,QAAQ;AAAA,MAC7B;AAAA,IACF;AAAA,IACA,QAAQ;AAAA,MACN,WAAW,EAAE,aAAa,MAAM;AAAA,MAAC,EAAE;AAAA,IACrC;AAAA,IACA,MAAM;AAAA,MACJ,aAAa,MAAM,QAAQ,QAAQ;AAAA,MACnC,OAAO,MAAM,QAAQ,QAAQ,CAAC,CAAC;AAAA,IACjC;AAAA,EACF;AACF,GAAG;AAmFH,IAAI,OAAQ,WAAmB,YAAY,aAAa;AACtD,EAAC,WAAmB,UAAU;AAChC;AACA,IAAI,OAAQ,WAAmB,WAAW,aAAa;AACrD,EAAC,WAAmB,SAAS;AAC/B;;;ACpJA,IAAM,uBAAuB,MAAM;AACjC,MAAI,CAAC,SAAS,cAAc,OAAO,GAAG;AACpC;AAAA,EACF;AACA,mBAAiB,WAAW;AAE5B,QAAM,gBAAgB,SAAS,cAAc,QAAQ;AACrD,gBAAc,MAAM,QAAQ,QAAQ,OAAO,4BAA4B;AACvE,WAAS,KAAK,OAAO,aAAa;AACpC;AACA,IAAM,mBAAmB,IAAI,iBAAiB,oBAAoB;AAClE,qBAAqB;AACrB,iBAAiB,QAAQ,UAAU;AAAA,EACjC,SAAS;AAAA,EACT,WAAW;AAAA,EACX,eAAe;AACjB,CAAC;",
  "names": []
}
